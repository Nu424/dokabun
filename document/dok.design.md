### どかぶん 設計書（CLI版・基本設計）

このドキュメントは、AI を用いたスプレッドシート駆動のバッチ分析ツール **「どかぶん」** の設計書です。
本書では、Python 製 CLI ツールとして実装する際の基本設計および主要な詳細設計を示します。

---

### 1. 前提・目的・スコープ

- **目的**

  - スプレッドシートをインターフェースとして、LLM によるテキスト・画像などの一括分析を「低コスト・低労力」で実現する。
  - 分析対象や出力形式をスプレッドシートで柔軟に記述できるようにし、ノーコードに近い運用を可能にする。
- **スコープ（本設計書で対象とする範囲）**

  - Python 製 CLI ツールとしての「どかぶん」第 1 版。
    - 実行方法：ターミナルからコマンドを実行（例：`python -m dokabun <spreadsheet_path>` など）。
    - 対応 OS：開発・利用の主対象は Windows だが、原則としてクロスプラットフォームを意識した設計とする。
  - 入力：ローカルに存在するスプレッドシートファイル（Excel / CSV）。
  - 分析対象：
    - プレーンテキスト
    - ローカル画像ファイル（パス指定）
  - 分析処理：
    - OpenRouter 経由で LLM（主にチャット補完 API）を呼び出し、**構造化出力（JSON Schema ベース）**を利用して結果を取得する。
  - 出力：
    - 原則として入力スプレッドシートと同一ファイル（もしくは同形式のコピー）に結果を追記する。
    - 途中経過保存および障害時リカバリのため、一時ファイルも出力する。
- **非スコープ（本設計書で対象外とするもの）**

  - GUI アプリケーション（デスクトップ / Web フロントエンド）。
  - LLM 以外の分析エンジン（例：ルールベース、機械学習モデル）の組み込み。
  - 複数ユーザーでの同時利用を前提としたサーバーサイド実装。
- **前提条件・設計方針**

  - Python バージョン：3.10 以上を想定。
  - 主要ライブラリの想定：
    - スプレッドシート I/O：`pandas`、`openpyxl`、`pyarrow` または同等のライブラリ。
    - 非同期処理：`asyncio`。
    - LLM 呼び出し：OpenRouter をバックエンドとする **OpenAI Python SDK**（`openai` パッケージ）。
    - 進捗表示：`tqdm`。
    - 設定管理：`pydantic` または単純な `dataclasses`。
  - OpenRouter API を用いて LLM を呼び出し、モデルは CLI オプションまたは設定ファイルで指定できるようにする。
  - 分析処理は非同期で行い、`asyncio.Semaphore` により同時並列数を制限する。
  - 関数・メソッドには Google スタイルの docstring を付与し、日本語の説明コメントを適宜追加して可読性を高める。
  - 将来的に以下の拡張が容易に行えるよう、モジュール分割と抽象化を意識する。
    - 対応する入力種別（PDF、Web ページ URL など）の追加。
    - 対応する LLM プロバイダ・モデルの追加。
    - 出力先（DB、別ファイル形式など）の変更。

---

### 2. 想定利用シナリオ

- **シナリオ A：Web ページ内容の一括解析（テキスト化済み）**
  - 事前にクローラー等で Web ページ内容をテキスト化し、スプレッドシートの `t_content` 列に格納しておく。
  - 他の列で「タイトル」「要約」「カテゴリ」「重要度」などの構造化出力項目を定義しておき、どかぶんで一括解析して埋める。
- **シナリオ B：画像ファイルの一括タグ付け**
  - ローカル画像ファイルへの相対パスを `t_image_path` 列に記入し、タグや説明文を出力する列を定義する。
  - どかぶんが画像を読み込み、LLM のマルチモーダル機能を用いてタグ・説明を構造化出力として書き込む。
- **シナリオ C：顧客フィードバックの構造化**
  - 顧客の自由記述フィードバックを `t_feedback` 列に記入し、感情ラベル・カテゴリ・要望の有無などを列として定義。
  - どかぶんにより、各行のフィードバックを解析し、これらの列を自動で埋める。

---

### 3. スプレッドシート仕様

#### 3.1 入力スプレッドシート形式

- **基本ルール**

  - スプレッドシートは、以下の 2 種類の列群で構成される。
    - **分析対象列（ターゲット列）**：`t_` で始まる列名（例：`t_content`, `t_image_path`）。
    - **分析結果列（出力列）**：それ以外の列名で、`{列名}` または `{列名}|{説明}` 形式でヘッダが記載される列。
  - ヘッダ行は 1 行目とし、2 行目以降がデータ行とする。
- **分析対象列（`t_xxx` 列）**

  - 列名が `t_` で始まる列をすべて「分析対象列」とみなす。
  - 複数の `t_` 列が存在する場合、**左から右の順**で結合し、1 つの入力テキスト（またはマルチモーダル入力）として扱う。
    - 例：`t_title` と `t_body` がある場合、`"[TITLE]\\n{t_title}\\n[BODY]\\n{t_body}"` のように結合する（具体的な結合フォーマットは後述の LLM 入力設計で定義）。
  - 初期版では、以下の 3 種類を正式サポートする。
    - プレーンテキスト（そのままプロンプトに使用）。
    - ローカル画像ファイルパス（スプレッドシートファイルからの相対パス）。
    - ローカルテキストファイルパス（`.txt`, `.md`, `.markdown`, `.log`, `.csv`, `.json`, `.yml`, `.yaml` など）。
      - ファイルを読み込んで内容をテキストとして LLM に渡す。
      - ファイルサイズが上限（デフォルト 256KiB）を超える場合はエラーとして扱う。
      - 文字コードは `utf-8-sig` → `utf-8` → `cp932` の順で自動判別を試みる。
  - 将来的に、URL・PDF なども対象とするが、本書では拡張しやすい抽象化の方針のみを定義する。
- **分析結果列（出力列）のヘッダ形式**

  - 出力列は、原則として **LLM 構造化出力のプロパティ**と 1 対 1 で対応する。
  - ヘッダの書き方：
    - `{列名}` だけ記載した場合：列名がそのままプロパティ名になる。説明は省略。
    - `{列名}|{説明}` と記載した場合：
      - `{列名}`：プロパティ名。
      - `{説明}`：構造化出力スキーマの `description` として利用される自然文。
  - 例：
    - `summary|本文の要約` → `summary` プロパティ。説明「本文の要約」。
    - `sentiment|ポジティブ・ネガティブなどの感情ラベル`。
- **分析対象セルとスキップ条件**

  - 各データ行に対して、「どの列を LLM で埋めるか」は次のルールで決まる。
    - 出力列のうち、**セルが空（もしくは事前定義された「未入力」判定）である場合のみ**分析対象とする。
    - すでに値が入っているセルは「手動で埋められた」「以前の実行結果がある」とみなし、どかぶんによる再上書き対象から除外する。

#### 3.2 サポートするファイル形式

- **入力スプレッドシート**

  - 初期サポート：
    - Excel（`.xlsx`）
    - CSV（UTF-8）
  - 読み込みは `pandas` を用い、内部的には `DataFrame` として扱う。
  - 将来的に Google Sheets / その他フォーマットを扱う場合に備え、I/O 層を抽象化（`SpreadsheetReader` インターフェース）して実装する。
- **出力スプレッドシート**

  - 基本方針：
    - 入力ファイルそのものは変更せず、実行ごとに **タイムスタンプ付きの Excel ファイル** を新規作成して出力先とする。
  - タイムスタンプ付き命名規則（`YYYYMMDD_hhmmss` 形式）例：
    - 実行開始時刻からタイムスタンプ文字列 `TS` を生成（例：`20251202_153045`）。
    - 実行元ファイル名：`input.xlsx`（拡張子を除いた部分を `input` とする）。
    - 処理対象となる元ファイル（コピー）：`input_TS.xlsx`（どかぶんが実際に読み書きする「元ファイル」。ユーザー入力のオリジナルは変更しない）
    - 最終出力ファイル：`input_TS.out.xlsx`
    - 一時ファイル：`input_TS.partial.<行番号範囲>.xlsx`

#### 3.3 一時ファイルと再開ロジック

- **一時ファイルの目的**

  - 長時間バッチ処理で、途中中断（例：エラー、ネットワーク障害、ユーザーが中断）しても、**途中から再開できる**ようにする。
- **運用方針**

  - 一定件数（例：N 行）ごとに、一時ファイルへ現在までの結果を保存する。
    - N は設定ファイルや CLI オプションで指定可能（デフォルト例：100 行）。
  - 一時ファイルには、「どこまで処理済みか」をメタデータとして記録する。
    - 例：最後に処理完了した行インデックス、エラー行の一覧など。
  - 再実行時には、以下の順で再開ポイントを判断する。
    1. 一時ファイルが存在するかを確認。
    2. 存在する場合、メタデータから「処理済み行」を読み取り、**未処理行のみ**を対象に再開。
    3. 一時ファイルがない場合は、元スプレッドシートを読み込んで新規実行とみなす。

---

### 4. 分析対象の抽象化と前処理

#### 4.1 分析対象タイプのモデル化

- `t_xxx` 列のセル値から、内部的には以下のような「分析対象タイプ」を判定する。

  - `TextTarget`：プレーンテキスト。セルの内容をそのまま、あるいは軽微な整形を施してプロンプトに渡す。
  - `ImageTarget`：画像ファイル。セルの内容をパスとして解釈し、実ファイルを読み込んで Base64 などに変換して LLM に渡す。
  - （将来）`UrlTarget`：URL。Web ページ取得＋前処理を行ったうえでテキストとして渡す。
  - （将来）`PdfTarget`：PDF ファイル。OpenRouter の PDF 機能や別サービスで前処理して渡す。
- 分析対象タイプは抽象クラス（あるいはプロトコル）で表現し、LLM に渡すための共通インターフェースを持つ。

  - 例：`to_llm_input()` でテキスト／マルチモーダル入力の共通表現を返す。

#### 4.2 前処理クラス設計

- 前処理の責務：

  - 「`t_xxx` セルの生の文字列」から、「LLM に渡すべき形式（テキスト、画像データなど）」へ変換する。
  - そのセルを自分が担当すべきかどうかを判定する。
- 抽象クラス `Preprocess`（イメージ）

  - `is_eligible(target_text: str) -> bool`
    - 与えられたセル値が、この前処理の担当範囲かどうかを判定。
    - 例：URL であれば `WebPreprocess` が True を返す、画像パス形式であれば `ImagePreprocess` が True を返す、など。
  - `preprocess(target_text: str) -> Target`（`Target` は上記の `TextTarget` などの型）
    - 実際の前処理を行い、内部表現（`Target`）を返す。
- 具体クラスの例

  - `PlainTextPreprocess`
    - すべての文字列を受け入れる（最後のフォールバック）。
    - 軽い正規化（改行整理、トリムなど）を行う。
  - `ImagePreprocess`
    - 画像拡張子（`.png`, `.jpg`, `.jpeg`, `.webp` 等）を含むパス文字列の場合に担当。
    - スプレッドシートファイルのディレクトリを基準に相対パスを解決し、ファイル存在チェックを行う。
  - `TextFilePreprocess`
    - テキストファイル拡張子（`.txt`, `.md`, `.markdown`, `.log`, `.csv`, `.json`, `.yml`, `.yaml` 等）を含むパス文字列の場合に担当。
    - スプレッドシートファイルのディレクトリを基準に相対パスを解決し、ファイル存在チェック・サイズ上限チェック・文字コード自動判別を行い、内容を `TextTarget` として返す。
  - （将来）`WebPreprocess`
    - URL 形式 (`http://` / `https://`) の文字列を担当。
    - HTTP 取得＋HTML からの本文抽出などを行い、`TextTarget` として返す。

#### 4.3 パス解決とエラーハンドリング

- パス解決

  - `t_xxx` のファイルパスは、**スプレッドシートファイルを基準とした相対パス** として解釈する。
  - 内部的には、スプレッドシートファイルのディレクトリと結合して絶対パスに変換する。
- エラーハンドリング

  - 画像ファイルなどが存在しない場合：
    - 該当行を「エラー行」として扱い、エラー内容をログへ記録。
    - その行の出力列は未入力のままとし、サマリーで件数と理由を報告。
  - 前処理中に例外が発生した場合：
    - 例外をキャッチし、行番号・列名とともにエラーログへ記録。
    - 原則として他行の処理は継続。

---

### 5. LLM 構造化出力と OpenRouter 設計

#### 5.1 構造化出力スキーマの定義ルール

- スキーマ生成の基本方針

  - 出力列ヘッダの `{列名}` / `{列名}|{説明}` から、JSON Schema の `properties` を構築する。
  - デフォルトではすべて `type: "string"` とし、必要に応じて別途設定で型を上書きできるようにする（第 1 版では単純な文字列で十分）。
  - 例：
    - `summary|本文の要約` →
      `properties.summary = { "type": "string", "description": "本文の要約" }`
- 必須項目の扱い

  - **すべての出力列を必須（`required`）とする。**
    - `required` 配列には、構築した `properties` の全プロパティ名を格納する。
    - これにより、LLM は各プロパティを必ず埋めた JSON を返すことが求められる（空文字列や `null` を使うかどうかはプロンプト設計で指示）。

#### 5.2 プロンプト設計の枠組み

- システムメッセージの例
  - 「あなたは入力テキストから情報を抽出し、指定された JSON Schema に完全準拠した JSON を返すアシスタントです。」等。
- ユーザーメッセージ構成
  - スプレッドシート 1 行分のコンテキストを、以下のようなテキストに整形して渡す。
    - 分析対象テキスト（結合済み `t_xxx`）。
    - 必要であれば、既知のメタ情報（例：ID、URL 等）も含める。
- 構造化出力
  - `response_format.type = "json_schema"` とし、`json_schema` フィールドに上記で組み立てたスキーマを渡す。

#### 5.3 OpenRouter 呼び出し仕様

- 共通設定（OpenAI SDK 経由）

  - Python の OpenAI SDK（`openai` パッケージ）を使用し、OpenRouter をバックエンドとするクライアントを生成する。
    - 例：`OpenAI(base_url="https://openrouter.ai/api/v1", api_key=OPENROUTER_API_KEY)` または同等の初期化。
  - 認証情報（`OPENROUTER_API_KEY`）は環境変数などから取得し、ソースコードにハードコードしない。
  - 実際の呼び出しは SDK のチャット補完 API（例：`client.chat.completions.create(...)` や非同期版）を利用する。
- モデル指定

  - CLI オプションまたは設定ファイルで、`model` 名（例：`openai/gpt-4.1-mini`）を指定。
  - 指定がない場合のデフォルトモデルを決めておく。
- 使用パラメータ（例）

  - `temperature`: 0.0〜0.7（デフォルトは 0.2 程度）。
  - `max_tokens`: 出力スキーマと期待される文字数に応じて設定。
  - `usage.include: true` を指定し、トークン数とコストを取得してサマリーに利用する。
- タイムアウト・リトライ・レートリミット

  - HTTP タイムアウト値を設定（例：60 秒）。
  - 一時的なネットワークエラーや 5xx エラーの際は、一定回数（例：3 回）まで指数バックオフでリトライ。
  - OpenRouter 側のレートリミットに配慮し、`asyncio.Semaphore` の同時実行数とリトライ間隔を調整。

---

### 6. 全体処理フローと並列実行

#### 6.1 全体フロー

1. 設定読み込み
   - CLI 引数と設定ファイル（任意）を読み込み、モデル名・同時並列数・一時ファイル設定などを決定。
2. スプレッドシート読み込み
   - 入力ファイルパスを受け取り、`SpreadsheetReader` で `DataFrame` として読み込む。
3. 再開ポイントの判定
   - 一時ファイルの有無を確認し、再開の場合は既存結果を読み込んで「未処理行リスト」を作成。
4. 行ごとの処理対象抽出
   - 各行について、出力列のうち空セルのみを「この実行で埋める対象」としてリストアップ。
5. 分析対象の前処理
   - `t_xxx` 列の値を取得し、前処理クラス群を用いて `Target` オブジェクトに変換。
6. LLM 呼び出し（非同期）
   - 行ごとに LLM へリクエストを送信し、構造化出力（JSON）を受け取る。
7. 結果反映
   - 取得した JSON の各プロパティを対応する出力列のセルに書き込む。
8. 一時保存・最終保存
   - 一定行数ごとに一時ファイルを書き出す。
   - 全行処理完了後、最終出力ファイルとして保存。
9. サマリー出力
   - 実行時間、トークン数・推定コスト、成功件数・失敗件数、主なエラーのサマリーを標準出力に表示。

#### 6.2 非同期・並列処理

- 実装方針

  - Python の `asyncio` を用い、LLM 呼び出しを非同期タスクとして実行。
  - `asyncio.Semaphore` により、同時に進行するリクエスト数を制限（例：デフォルト 5〜10）。
  - I/O バウンド（ネットワーク通信）が中心であるため、CPU 使用率は低く抑えられる。
- 例外処理

  - 個々のタスク内で例外が発生した場合は、その行だけ失敗扱いとし、詳細をログに記録。
  - 他のタスクは継続して処理する。
- 進捗表示

  - `tqdm` を用いて、処理対象となる行数に対して進捗バーを表示。
  - 成功・失敗にかかわらず「処理完了行数」としてカウントアップする。
- キャンセル（ユーザー中断）時の挙動

  - `KeyboardInterrupt`（Ctrl+C）検知時：
    - 進行中タスクをキャンセルし、直近で安定した状態の一時ファイルを保存。
    - 中断時点のサマリー（処理済み件数など）を簡易表示。

---

### 7. モジュール構成と主要コンポーネント

#### 7.1 パッケージ構成案

- `dokabun/`
  - `__init__.py`
  - `cli.py`：エントリポイント（CLI パーサ、メイン処理起動）。
  - `config.py`：設定読み込み・検証（モデル名、並列数、一時ファイル設定など）。
  - `io/`
    - `spreadsheet.py`：スプレッドシートの読み書き、再開用メタデータ管理。
  - `preprocess/`
    - `base.py`：`Preprocess` 抽象クラス定義。
    - `text.py`：`PlainTextPreprocess` と `TextFilePreprocess` 実装。
    - `image.py`：`ImagePreprocess` 実装。
    - （将来）`web.py`：`WebPreprocess` 実装。
  - `target.py`：`TextTarget` / `ImageTarget` などの内部表現。
  - `llm/`
    - `openrouter_client.py`：OpenAI SDK を利用した OpenRouter 呼び出しラッパ。
    - `schema.py`：出力スキーマ（JSON Schema）生成ロジック。
    - `prompt.py`：プロンプトテンプレート生成。
  - `core/`
    - `runner.py`：1 行単位の処理ロジック、非同期制御、進捗管理。
    - `summary.py`：サマリー集計・表示。
  - `logging_utils.py`：ログ設定と共通のロガー取得。

#### 7.2 主要クラス／関数の責務（概要）

- `cli.main(args)`
  - CLI 引数をパースし、設定を生成して `core.runner.run()` を呼び出す。
- `config.AppConfig`
  - モデル名、同時並列数、入出力ファイルパス、一時ファイル設定などを保持する設定クラス。
- `io.spreadsheet.SpreadsheetReaderWriter`
  - スプレッドシートファイルの読み書き。
  - 一時ファイルの生成とメタデータ（処理済み行インデックスなど）の管理。
- `preprocess.base.Preprocess`
  - `is_eligible` / `preprocess` を定義する抽象クラス。
- `preprocess.text.PlainTextPreprocess`
  - プレーンテキストの前処理（フォールバック用）。
- `preprocess.text.TextFilePreprocess`
  - テキストファイルパスからファイルを読み込み、内容を `TextTarget` として返す。
  - ファイル存在チェック・サイズ上限チェック・文字コード自動判別を行う。
- `preprocess.image.ImagePreprocess`
  - 画像パスから `ImageTarget` を生成し、存在チェックや Base64 変換を行う。
- `target.TextTarget` / `target.ImageTarget`
  - LLM に渡すための統一インターフェース（例：`to_llm_content()`）。
- `llm.schema.build_schema_from_headers(headers)`
  - スプレッドシートの出力列ヘッダから JSON Schema を構築する。
- `llm.prompt.build_prompt(row, targets, schema)`
  - 1 行分のデータからプロンプトメッセージ（`messages` 配列）を組み立てる。
- `llm.openrouter_client.AsyncOpenRouterClient`
  - 非同期で OpenRouter にリクエストを送り、構造化出力を取得するクライアント。
- `core.runner.run(config)`
  - 全体フローを統括する関数。行ごとのタスク生成、`asyncio` による並列実行、途中保存などを制御。
- `core.summary.ExecutionSummary`
  - 実行時間、トークン数、コスト、成功・失敗件数などを集計し、レポートを生成する。

---

### 8. エラー処理・ログ・サマリー

#### 8.1 エラー分類とハンドリング方針

- 入力ファイル関連エラー
  - ファイルが存在しない／読み込めない場合は即時終了し、エラーメッセージを表示。
- パス解決・ファイル読み込みエラー
  - 対象行をスキップし、エラー内容をログに記録。
- LLM 呼び出しエラー
  - 一時的なエラー（タイムアウト、5xx など）の場合はリトライ。
  - それでも失敗した場合は該当行を失敗として記録。
- 不明な例外
  - ログにスタックトレースを記録し、原則として残りの処理は継続。

#### 8.2 ログ設計

- ログレベル

  - `INFO`：通常の進行状況（ファイル開始・終了、一時保存のタイミングなど）。
  - `WARNING`：一部の行で発生した recoverable な問題。
  - `ERROR`：処理をスキップせざるを得ないエラー。
  - `DEBUG`：開発・デバッグ用の詳細情報（オプションで有効化）。
- 出力先

  - 標準出力：高レベルな進捗と最終サマリー。
  - ログファイル：詳細な行レベルのエラー・警告情報（例：`dokabun.log`）。

#### 8.3 サマリー出力

- サマリーに含める情報
  - 実行開始時刻・終了時刻・総実行時間。
  - 対象行数、成功行数、失敗行数。
  - LLM 呼び出しの総トークン数（入力・出力）と推定コスト（USD）。
  - 主なエラー種別と件数（例：ファイル未存在 N 件、LLM タイムアウト M 件）。

---

### 9. 拡張性と今後の拡張案

- 入力種別の拡張
  - `UrlTarget` / `PdfTarget` などのターゲット型と、それに対応する `Preprocess` 実装を追加するだけで新しい種別を扱えるようにする。
- LLM プロバイダ・モデルの拡張
  - OpenRouter 経由で他プロバイダのモデルを利用する場合も、モデル名・追加設定を変更するだけで対応できるよう、OpenAI SDK ベースの `AsyncOpenRouterClient` を汎用的に設計する。
- 出力先の拡張
  - 将来的にデータベースや別フォーマット（JSONL 等）に結果を保存するニーズに備え、`Writer` インターフェースを導入する余地を残す。
- CLI 機能の拡張
  - dry-run モード（実際には LLM を呼ばずに、どの行が対象になるかだけ確認）。
  - サマリーのみを JSON で出力するオプションなど。

---

この設計書をベースに、`dokabun` パッケージの実装を段階的に進めていく。
